---
phase: 5-type-unification
plan: 02
type: execute
wave: 2
depends_on: ["5-01"]
files_modified:
  - .github/workflows/ci.yml
  - scripts/generate-types.sh
autonomous: true

must_haves:
  truths:
    - "CI generates TypeScript types from Rust before frontend build"
    - "CI fails if generated types are stale (drift detection)"
    - "Build process ensures type synchronization"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Type generation step in CI"
      contains: "generate-types"
    - path: "scripts/generate-types.sh"
      provides: "Reusable type generation script"
      contains: "TS_RS_EXPORT_DIR"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "scripts/generate-types.sh"
      via: "CI runs script"
      pattern: "generate-types.sh"
    - from: "scripts/generate-types.sh"
      to: "src/generated/bindings.ts"
      via: "generates types"
      pattern: "cargo test export_bindings"
---

<objective>
Add CI verification to detect type drift between Rust and TypeScript.

Purpose: Build fails if types drift, preventing silent incompatibilities from reaching production.
Output: CI workflow that generates types and verifies they match committed files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/5-type-unification/5-RESEARCH.md
@.planning/phases/5-type-unification/5-01-SUMMARY.md

@.github/workflows/ci.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type generation script</name>
  <files>
    scripts/generate-types.sh
  </files>
  <action>
1. Create scripts/ directory if it doesn't exist

2. Create scripts/generate-types.sh:
   ```bash
   #!/bin/bash
   # Generate TypeScript types from Rust using ts-rs
   # Usage: ./scripts/generate-types.sh

   set -e

   SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
   PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

   # Set export directory for ts-rs
   export TS_RS_EXPORT_DIR="$PROJECT_ROOT/src/generated"

   # Create output directory
   mkdir -p "$TS_RS_EXPORT_DIR"

   echo "Generating TypeScript types..."
   echo "Output directory: $TS_RS_EXPORT_DIR"

   # Run the export test to generate types
   cd "$PROJECT_ROOT/src-tauri"
   cargo test export_bindings --release -- --nocapture

   # ts-rs generates separate files - combine into single bindings.ts
   cd "$TS_RS_EXPORT_DIR"

   # Create combined bindings file
   cat > bindings.ts << 'EOF'
   // Auto-generated by ts-rs from Rust types. Do not edit manually.
   // Regenerate with: ./scripts/generate-types.sh

   EOF

   # Append each generated type file
   for f in AppMode.ts Theme.ts LatencyThresholds.ts AppConfig.ts; do
       if [ -f "$f" ]; then
           cat "$f" >> bindings.ts
           echo "" >> bindings.ts
       fi
   done

   # Remove individual files (keep only combined bindings.ts)
   rm -f AppMode.ts Theme.ts LatencyThresholds.ts AppConfig.ts

   echo "TypeScript types generated successfully: $TS_RS_EXPORT_DIR/bindings.ts"
   ```

3. Make script executable: `chmod +x scripts/generate-types.sh`

AVOID: Hardcoding absolute paths - use relative paths from script location.
  </action>
  <verify>
./scripts/generate-types.sh
cat src/generated/bindings.ts | head -20
  </verify>
  <done>
Script executes successfully, generates combined bindings.ts with all types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add type verification to CI workflow</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
1. Add a new job "typecheck" that runs on all pushes/PRs (not just releases)

2. Add after the existing jobs section, before build-and-upload:
   ```yaml
   # Type checking runs on all pushes and PRs
   typecheck:
     name: Type Check
     runs-on: ubuntu-latest
     steps:
       - uses: actions/checkout@v6

       - name: Setup Node.js
         uses: actions/setup-node@v6
         with:
           node-version: '22'

       - name: Setup pnpm
         uses: pnpm/action-setup@v4
         with:
           version: 10

       - name: Setup Rust
         uses: dtolnay/rust-toolchain@stable

       - name: Rust cache
         uses: swatinem/rust-cache@v2
         with:
           workspaces: './src-tauri -> target'

       - name: Install frontend dependencies
         run: pnpm install

       - name: Generate TypeScript types from Rust
         run: ./scripts/generate-types.sh

       - name: Check for type drift
         run: |
           # If generated types differ from committed, fail the build
           if ! git diff --exit-code src/generated/bindings.ts; then
             echo "ERROR: Generated types differ from committed types!"
             echo "Run './scripts/generate-types.sh' locally and commit the changes."
             exit 1
           fi

       - name: TypeScript type check
         run: pnpm exec tsc --noEmit

       - name: Run frontend tests
         run: pnpm test:run
   ```

3. Ensure the typecheck job doesn't have any dependencies (runs independently)

4. The build-and-upload job should continue to only run on releases (no changes needed there)

AVOID: Making typecheck depend on release-please - it should run on every push/PR.
  </action>
  <verify>
# Verify CI file is valid YAML
cat .github/workflows/ci.yml | head -100
# Check that typecheck job exists
grep -A 5 "typecheck:" .github/workflows/ci.yml
  </verify>
  <done>
CI workflow has typecheck job that generates types and verifies no drift, runs on all pushes/PRs.
  </done>
</task>

</tasks>

<verification>
1. `./scripts/generate-types.sh` runs without errors
2. `cat src/generated/bindings.ts` shows combined generated types
3. `git diff src/generated/bindings.ts` shows no changes (types match)
4. `.github/workflows/ci.yml` has typecheck job
5. Typecheck job includes: type generation, drift check, tsc, tests
</verification>

<success_criteria>
- scripts/generate-types.sh is executable and generates types
- CI workflow has typecheck job that runs on all pushes/PRs
- Typecheck job generates types and checks for drift
- Typecheck job runs tsc --noEmit and frontend tests
- Build fails if generated types don't match committed types
</success_criteria>

<output>
After completion, create `.planning/phases/5-type-unification/5-02-SUMMARY.md`
</output>
